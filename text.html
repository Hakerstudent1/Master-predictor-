<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ðŸ‘‘ DURVESH VIP ðŸ‘‘ â€” Full Blocks (Only 10 Visible)</title>
<style>
  :root{
    --gold: #d4af37;
    --bg1: #0b0b0b;
    --bg2: #131313;
    --muted: rgba(255,255,255,0.08);
  }
  html,body{height:100%;margin:0;font-family:Inter, "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{
    background: radial-gradient(circle at top left, #151515 0%, #050505 100%);
    color: var(--gold);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:28px;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .card{
    width:100%;
    max-width:980px;
    padding:28px;
    border-radius:16px;
    background: linear-gradient(180deg, rgba(212,175,55,0.03), rgba(212,175,55,0.01));
    box-shadow: 0 10px 40px rgba(0,0,0,0.7), 0 0 18px rgba(212,175,55,0.06);
    border: 1px solid rgba(212,175,55,0.08);
  }

  .header{
    display:flex;
    align-items:center;
    gap:16px;
    margin-bottom:18px;
  }
  .logo{
    height:56px;
    width:56px;
    border-radius:10px;
    display:grid;
    place-items:center;
    background: linear-gradient(135deg, rgba(212,175,55,0.18), rgba(212,175,55,0.08));
    border:1px solid rgba(212,175,55,0.12);
    font-weight:700;
    font-size:18px;
    color:var(--gold);
    box-shadow: 0 6px 18px rgba(212,175,55,0.04);
  }
  h1{margin:0;font-size:20px;letter-spacing:0.6px;color:var(--gold)}
  p.lead{margin:0;color:rgba(255,255,255,0.35);font-size:13px}

  /* Blocks grid - but only block10 shown */
  .blocks {
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap:12px;
    margin-top:20px;
  }

  .block{
    padding:16px;
    border-radius:12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    min-height:92px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    align-items:center;
  }

  /* Only block10 visible */
  .block.hidden{display:none}

  #block10{display:flex; flex-direction:column; align-items:center; justify-content:center; border:2px solid rgba(212,175,55,0.25); box-shadow:0 12px 36px rgba(212,175,55,0.06);}

  .title{
    font-size:14px;
    font-weight:700;
    color:var(--gold);
    text-shadow:0 0 8px rgba(212,175,55,0.08);
    margin-bottom:6px;
  }

  .prediction{
    font-size:34px;
    font-weight:800;
    letter-spacing:2px;
    margin:4px 0;
    text-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }

  .meta{
    font-size:12px;
    color:rgba(255,255,255,0.45);
    margin-top:6px;
    text-align:center;
  }

  .color-big{ color:#9ef39e; }    /* greenish */
  .color-small{ color:#ff9c9c; }  /* reddish */
  .color-error{ color:#ff6b6b; }

  .loader {
    width:22px;height:22px;border-radius:50%;
    border:3px solid rgba(255,255,255,0.06);
    border-left:3px solid var(--gold);
    animation:spin 1s linear infinite;
    display:inline-block;
    vertical-align:middle;
  }
  @keyframes spin{100%{transform:rotate(360deg)}}

  /* small readout used for hidden blocks to avoid console clutter */
  .small-readout{font-size:12px;color:rgba(255,255,255,0.3);margin-top:6px}
  .nowrap{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  /* footer */
  .footer{margin-top:18px;color:rgba(255,255,255,0.12);font-size:12px;text-align:center}
</style>
</head>
<body>
  <div class="card" role="main" aria-label="Durvesh VIP prediction dashboard">
    <div class="header">
      <div class="logo">VIP</div>
      <div>
        <h1>ðŸ‘‘ DURVESH VIP ðŸ‘‘</h1>
        <p class="lead">All 10 blocks run in background â€” only Block 10 is visible. Live API: <code>/api/get-history</code></p>
      </div>
    </div>

    <div class="blocks" id="blocksGrid">
      <!-- Blocks 1..9 are present but hidden (run in background). Block 10 visible. -->
      <div id="block1" class="block hidden">
        <div class="title">Block 1</div>
        <div id="prediction-b1" class="prediction">--</div>
        <div id="meta-b1" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block2" class="block hidden">
        <div class="title">Block 2</div>
        <div id="prediction-b2" class="prediction">--</div>
        <div id="meta-b2" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block3" class="block hidden">
        <div class="title">Block 3</div>
        <div id="prediction-b3" class="prediction">--</div>
        <div id="meta-b3" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block4" class="block hidden">
        <div class="title">Block 4</div>
        <div id="prediction-b4" class="prediction">--</div>
        <div id="meta-b4" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block5" class="block hidden">
        <div class="title">Block 5</div>
        <div id="prediction-b5" class="prediction">--</div>
        <div id="meta-b5" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block6" class="block hidden">
        <div class="title">Block 6</div>
        <div id="prediction-b6" class="prediction">--</div>
        <div id="meta-b6" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block7" class="block hidden">
        <div class="title">Block 7</div>
        <div id="prediction-b7" class="prediction">--</div>
        <div id="meta-b7" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block8" class="block hidden">
        <div class="title">Block 8</div>
        <div id="prediction-b8" class="prediction">--</div>
        <div id="meta-b8" class="meta small-readout">Backtest: --%</div>
      </div>

      <div id="block9" class="block hidden">
        <div class="title">Block 9</div>
        <div id="prediction-b9" class="prediction">--</div>
        <div id="meta-b9" class="meta small-readout">Backtest: --%</div>
      </div>

      <!-- Visible block 10 -->
      <div id="block10" class="block">
        <div class="title">ðŸ‘‘ DURVESH VIP ðŸ‘‘ â€” Block 10</div>
        <div id="prediction-b10" class="prediction nowrap"><span class="loader" aria-hidden="true"></span> Loading...</div>
        <div id="meta-b10" class="meta">Backtesting: --%</div>
      </div>
    </div>

    <div class="footer">History capped at latest 21 entries â€” older entries trimmed automatically.</div>
  </div>

<script>
/*
  Full multi-block script.
  - Keeps live endpoint as /api/get-history (unchanged per your request)
  - Fetches pages until it has 21 unique periods (or stops if API returns fewer)
  - Keeps in-memory history trimmed to 21 (deletes 22+)
  - Runs background prediction/backtesting for Blocks 1..9 (hidden)
  - Shows Block 10 only; all blocks updated on each fetch cycle
  - Poll interval: 8000 ms (8 seconds) to match your earlier preference
*/

(function(){
  const API_ENDPOINT = "/api/get-history"; // kept exactly as requested

  const app = {
    oneMinHistory: [],        // newest-first array of { period, number, size }
    pollIntervalMs: 8000,
    desiredCount: 21,
    pageSize: 10,
    maxPages: 6,              // safety cap (up to 60 items fetched)
    blocksCount: 10,

    delay(ms){ return new Promise(r => setTimeout(r, ms)); },

    init(){
      // initial load then periodic polling
      this.loadCycle();
      this._ticker = setInterval(()=> this.loadCycle(), this.pollIntervalMs);
    },

    async loadCycle(){
      const ok = await this.fetchHistoryPages();
      if(ok){
        // ensure always trimmed to desiredCount
        if(this.oneMinHistory.length > this.desiredCount){
          this.oneMinHistory = this.oneMinHistory.slice(0, this.desiredCount);
        }
        // update all blocks (1..10). Block1..9 are hidden but logic runs
        for(let i=1;i<=this.blocksCount;i++){
          try{ this[`generateBlock${i}Prediction`](); }catch(e){ console.error(`gen block ${i} error`, e); }
        }
      } else {
        this.showApiError();
      }
    },

    showApiError(){
      const el = document.getElementById("prediction-b10");
      if(el){
        el.textContent = "API Error â€” Check Console";
        el.className = "prediction color-error";
      }
    },

    async fetchHistoryPages(){
      try{
        let pageNo = 1;
        let collected = [];
        while(collected.length < this.desiredCount && pageNo <= this.maxPages){
          const body = {
            pageSize: this.pageSize,
            pageNo,
            typeId: 1,
            language: 0,
            random: "c2505d9138da4e3780b2c2b34f2fb789",
            signature: "7D637E060DA35C0C6E28DC6D23D71BED",
            timestamp: Math.floor(Date.now()/1000)
          };

          const resp = await fetch(API_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });

          if(!resp.ok){
            console.warn("fetchHistoryPages: non-ok response", resp.status);
            return false;
          }

          const json = await resp.json();
          if(typeof json !== "object"){
            console.warn("fetchHistoryPages: invalid json");
            return false;
          }

          // Expecting structure similar to previous file: { code:0, data:{ list: [...] } }
          if(json.code !== 0){
            console.warn("fetchHistoryPages: api code not zero", json.code, json.msg);
            // If API returns code signaling no data yet, still continue gracefully
            if(pageNo === 1) return false;
            break;
          }

          const list = (json.data && Array.isArray(json.data.list)) ? json.data.list : [];
          if(list.length === 0){
            // nothing more to fetch
            break;
          }

          // Map server items to simplified items; ensure consistent fields
          const mapped = list.map(item=>{
            const numRaw = (item.number !== undefined && item.number !== null) ? String(item.number) : "0";
            // defensive parse: take last digit if server returns a multi-digit number
            const lastChar = numRaw.trim().slice(-1);
            const num = isNaN(parseInt(lastChar,10)) ? 0 : parseInt(lastChar,10);
            return {
              period: item.issueNumber ?? (`P${Date.now()}${Math.random().toString(36).slice(2,6)}`),
              number: num,
              size: (num <= 4) ? "SMALL" : "BIG"
            };
          });

          // append unique by period (collected newest-first)
          const existingPeriods = new Set(collected.map(i=>i.period));
          const newUnique = mapped.filter(i=>!existingPeriods.has(i.period));
          collected = collected.concat(newUnique);

          // if server returned fewer items than pageSize, stop early
          if(list.length < this.pageSize) break;

          pageNo++;
          await this.delay(120); // polite short pause
        }

        // Merge collected newest-first with existing oneMinHistory, preserving uniqueness and newest-first
        const currentPeriods = new Set(this.oneMinHistory.map(i=>i.period));
        const trulyNew = collected.filter(i=>!currentPeriods.has(i.period));
        // collected is newest-first because page 1 is newest -> we appended pages, so keep order
        this.oneMinHistory = trulyNew.concat(this.oneMinHistory);

        // Trim to desiredCount immediately (delete 22+)
        if(this.oneMinHistory.length > this.desiredCount){
          this.oneMinHistory = this.oneMinHistory.slice(0, this.desiredCount);
        }

        return true;
      }catch(err){
        console.error("fetchHistoryPages error:", err);
        return false;
      }
    },

    // ---------- Block Generators ----------
    // Each block uses a deterministic but different simple rule so they operate independently.
    // All blocks read from this.oneMinHistory (newest-first). If not enough history, show loader/wait.

    // Utility: safe read number at index (0 newest)
    numAt(idx){ return (this.oneMinHistory[idx] && typeof this.oneMinHistory[idx].number === "number") ? this.oneMinHistory[idx].number : null; },

    generateBlock1Prediction(){
      const el = document.getElementById("prediction-b1");
      const meta = document.getElementById("meta-b1");
      if(this.oneMinHistory.length < 5){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 5+ history";
        return;
      }
      // rule: parity of sum of first 2 => BIG if sum>=10 else SMALL
      const a = this.numAt(0), b = this.numAt(1);
      const sum = a + b;
      const res = (sum >= 10) ? "BIG" : "SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest simple: compare predicted to actual next's size for historical pairs
      let wins=0, total=0;
      for(let i=0;i+1 < this.oneMinHistory.length;i++){
        const p = (this.oneMinHistory[i].number + this.oneMinHistory[i+1].number) >= 10 ? "BIG":"SMALL";
        if(p === this.oneMinHistory[i+1].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock2Prediction(){
      const el = document.getElementById("prediction-b2");
      const meta = document.getElementById("meta-b2");
      if(this.oneMinHistory.length < 4){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 4+ history";
        return;
      }
      // rule: moving average of first 3 digits >4 => BIG else SMALL
      const a=this.numAt(0), b=this.numAt(1), c=this.numAt(2);
      const avg = (a+b+c)/3;
      const res = (avg > 4) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+2<this.oneMinHistory.length;i++){
        const avgH = (this.oneMinHistory[i].number + this.oneMinHistory[i+1].number + this.oneMinHistory[i+2].number)/3;
        const p = avgH > 4 ? "BIG":"SMALL";
        if(p === this.oneMinHistory[i+2].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock3Prediction(){
      const el = document.getElementById("prediction-b3");
      const meta = document.getElementById("meta-b3");
      if(this.oneMinHistory.length < 3){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 3+ history";
        return;
      }
      // rule: parity of latest number (even->BIG else SMALL)
      const a=this.numAt(0);
      const res = (a % 2 === 0) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+1<this.oneMinHistory.length;i++){
        const p = (this.oneMinHistory[i].number %2 === 0) ? "BIG":"SMALL";
        if(p === this.oneMinHistory[i+1].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock4Prediction(){
      const el = document.getElementById("prediction-b4");
      const meta = document.getElementById("meta-b4");
      if(this.oneMinHistory.length < 6){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 6+ history";
        return;
      }
      // rule: majority of last 5 being BIG/SMALL -> predict majority
      let big=0, small=0;
      for(let i=0;i<5;i++){
        if(this.oneMinHistory[i].size === "BIG") big++; else small++;
      }
      const res = (big >= small) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest: sliding window
      let wins=0,total=0;
      for(let i=0;i+6 <= this.oneMinHistory.length;i++){
        let bigc=0, smallc=0;
        for(let j=0;j<5;j++){ if(this.oneMinHistory[i+j].size==="BIG") bigc++; else smallc++; }
        const p = (bigc>=smallc)?"BIG":"SMALL";
        if(p === this.oneMinHistory[i+5].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock5Prediction(){
      const el = document.getElementById("prediction-b5");
      const meta = document.getElementById("meta-b5");
      if(this.oneMinHistory.length < 2){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 2+ history";
        return;
      }
      // rule: difference between first two -> odd=>SMALL even=>BIG
      const a=this.numAt(0), b=this.numAt(1);
      const diff = Math.abs(a-b);
      const res = (diff %2 === 0) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+1<this.oneMinHistory.length;i++){
        const d = Math.abs(this.oneMinHistory[i].number - this.oneMinHistory[i+1].number);
        const p = (d%2===0)?"BIG":"SMALL";
        if(p === this.oneMinHistory[i+1].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock6Prediction(){
      const el = document.getElementById("prediction-b6");
      const meta = document.getElementById("meta-b6");
      if(this.oneMinHistory.length < 7){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 7+ history";
        return;
      }
      // rule: sum of digits at indices 0,2,4 mod 10 >4 => BIG else SMALL
      const a=this.numAt(0), b=this.numAt(2), c=this.numAt(4);
      const s = (a+b+c) % 10;
      const res = (s>4)?"BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+4<this.oneMinHistory.length;i++){
        const sumH = (this.oneMinHistory[i].number + this.oneMinHistory[i+2].number + this.oneMinHistory[i+4].number) %10;
        const p = (sumH>4)?"BIG":"SMALL";
        if(p === this.oneMinHistory[i+5].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock7Prediction(){
      const el = document.getElementById("prediction-b7");
      const meta = document.getElementById("meta-b7");
      if(this.oneMinHistory.length < 3){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 3+ history";
        return;
      }
      // rule: median of first three digits <=4 => SMALL else BIG
      const arr=[this.numAt(0),this.numAt(1),this.numAt(2)].sort((x,y)=>x-y);
      const med = arr[1];
      const res = (med <= 4) ? "SMALL":"BIG";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+2<this.oneMinHistory.length;i++){
        const arrH=[this.oneMinHistory[i].number,this.oneMinHistory[i+1].number,this.oneMinHistory[i+2].number].sort((x,y)=>x-y);
        const p = (arrH[1] <=4) ? "SMALL":"BIG";
        if(p === this.oneMinHistory[i+2].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock8Prediction(){
      const el = document.getElementById("prediction-b8");
      const meta = document.getElementById("meta-b8");
      if(this.oneMinHistory.length < 10){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 10+ history";
        return;
      }
      // rule: take digits at 0 and 9 -> sum mod10 >4 => BIG else SMALL
      const a=this.numAt(0), b=this.numAt(9);
      const res = ((a+b)%10 >4) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+9<this.oneMinHistory.length;i++){
        const p = ((this.oneMinHistory[i].number + this.oneMinHistory[i+9].number) %10 >4) ? "BIG":"SMALL";
        if(p === this.oneMinHistory[i+10]?.size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock9Prediction(){
      const el = document.getElementById("prediction-b9");
      const meta = document.getElementById("meta-b9");
      if(this.oneMinHistory.length < 8){
        if(el) el.textContent = "Waiting...";
        if(meta) meta.textContent = "Need 8+ history";
        return;
      }
      // rule: parity of sum of indices 0..3 -> even->BIG else SMALL
      let s=0;
      for(let i=0;i<4;i++) s += this.oneMinHistory[i].number;
      const res = (s % 2 === 0) ? "BIG":"SMALL";
      if(el) { el.textContent = res; el.className = "prediction " + (res==="BIG"?"color-big":"color-small"); }
      // backtest
      let wins=0,total=0;
      for(let i=0;i+4<this.oneMinHistory.length;i++){
        let sumH=0;
        for(let j=0;j<4;j++) sumH += this.oneMinHistory[i+j].number;
        const p = (sumH%2===0)?"BIG":"SMALL";
        if(p === this.oneMinHistory[i+4].size) wins++;
        total++;
      }
      if(meta) meta.textContent = `Backtest: ${ total?((wins/total*100).toFixed(1)):'--'}%`;
    },

    generateBlock10Prediction(){
      const el = document.getElementById("prediction-b10");
      const meta = document.getElementById("meta-b10");
      if(this.oneMinHistory.length < this.desiredCount){
        if(el) el.innerHTML = `<span class="loader" aria-hidden="true"></span> Waiting for ${this.desiredCount} results...`;
        if(meta) meta.textContent = `History: ${this.oneMinHistory.length}/${this.desiredCount}`;
        return;
      }
      // This is the rule you asked earlier: take first and second numbers, add them,
      // then incorporate previous block prediction style: here we combine with 21st index.
      const first = this.oneMinHistory[0].number;
      const second = this.oneMinHistory[1].number;
      const added = first + second;
      const lastPrediction = (this.oneMinHistory[20].number + added) % 10;
      const result = (lastPrediction <= 4) ? "SMALL":"BIG";

      if(el){
        el.textContent = result;
        el.className = "prediction " + (result === "BIG" ? "color-big" : "color-small");
      }

      // Backtesting for this specific rule
      let wins=0, total=0;
      // We'll test historical windows where index i+20 exists
      for(let i=0;i+20 < this.oneMinHistory.length;i++){
        const pred = ((this.oneMinHistory[i].number + this.oneMinHistory[i+1].number + this.oneMinHistory[i+20].number) %10 <=4) ? "SMALL":"BIG";
        if(pred === this.oneMinHistory[i+21]?.size) wins++;
        total++;
      }
      // If we don't have sliding windows for full rule, fallback to simpler backtest:
      if(total === 0){
        // simpler: use (num[i] + num[i+1]) % 10 vs next size
        for(let i=0;i+1 < this.oneMinHistory.length;i++){
          const pred2 = ((this.oneMinHistory[i].number + this.oneMinHistory[i+1].number) %10 <=4) ? "SMALL":"BIG";
          if(pred2 === this.oneMinHistory[i+1].size) wins++;
          total++;
        }
      }
      const rate = total ? ((wins/total)*100).toFixed(1) : "--";
      if(meta) meta.textContent = `Backtesting: ${rate}% â€” History: ${this.oneMinHistory.length}/${this.desiredCount}`;
    }
  };

  // Start app
  app.init();

  // Expose for debug (optional)
  window.__DURVESH_VIP = app;

})();
</script>
</body>
</html>